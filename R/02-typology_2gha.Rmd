## Ghana

```{r, include=F}

load("../tmp/2017-agra-aasr_GHA.RData")

```

```{r gha-glss, eval=FALSE}

library(foreign)
library(data.table)
library(survey)
library(tables)
library(stringr)

setwd("~/Projects/2017-agra-aasr")
load("./tmp/2017-agra-aasr_GHA.RData")

# Pull complete sets from each wave, extract and describe:
# - cro pproduction
# - crop sales
# - off and on-farm income
# - cultivated area
# - region, district, ez, loc5, cluster
# - urban/rural
# Them combine all 3 waves once results make sense.

#####################################################################################
# GLSS6
gha12.hh <- read.dta("~/Projects/hc-data/GHA-GLSS6/raw/PARTA/g6loc_edt.dta")
gha12.hh.lbl <- data.table(varCode=names(gha12.hh), varLabel=attr(gha12.hh, "var.labels"))
gha12.hh <- data.table(gha12.hh)
  
gha12.inc <- read.dta("~/Projects/hc-data/GHA-GLSS6/raw/AGGREGATES/GHA_2013_INCOME.dta")
# => seems to already contain all needed income aggregates
gha12.inc.lbl <- data.table(varCode=names(gha12.inc), varLabel=attr(gha12.inc, "var.labels"))
gha12.inc <- data.table(gha12.inc)


#####################################################################################
# GLSS5
# Quick inventory of existing data extracts
glss5.input <- read.dta("~/Projects/hc-data/GHA-GLSS5/temp/GHA_GLSS5-08_inputs.12.dta")
glss5.bio <- read.dta("~/Projects/hc-data/GHA-GLSS5/temp/gha-glss5_L2_bio.dta")
# => CELL5M and WorldClim bio1-19 vars
data.table(varCode=names(glss5.input), varLabel=attr(glss5.input, "var.labels"))
#               varCode                               varLabel
#  1:              hhid        household identification number
#  2:             clust                         cluster number
#  3:            weight Sample weight for glss4 (=1 for glss3)
#  4:           landcul        Land cultivated by hh, hectares
#  5: ino_fert_value_hh                      Value of ino_fert
#  6: org_fert_value_hh                      Value of org_fert
#  7:     pest_value_hh                          Value of pest
#  8:     seed_value_hh                          Value of seed
#  9:       org_fert_hh                Household uses org_fert
# 10:       ino_fert_hh                Household uses ino_fert
# 11:           seed_hh                    Household uses seed
# 12:           pest_hh                    Household uses pest

gha05.hh <- read.dta("~/Projects/hc-data/GHA-GLSS5/temp/gha-glss5_processed.dta")
# => has a full set of hhlds
gha05.inc <- read.dta("~/Projects/hc-data/GHA-GLSS5/riga/Ghana05_HH_INCOME.dta")
# => has RIGA income aggs
gha05.hh.lbl <- data.table(varCode=names(gha05.hh), varLabel=attr(gha05.hh, "var.labels"))
gha05.hh <- data.table(gha05.hh)
gha05.inc.lbl <- data.table(varCode=names(gha05.inc), varLabel=attr(gha05.inc, "var.labels"))
gha05.inc <- data.table(gha05.inc)


#####################################################################################
# GLSS4
load("~/Projects/hc-data/GHA-GLSS4/temp/GHA-GLSS4.RData")
gha97.lbl <- lapply(names(micro), function(x) data.table(varCode=names(micro[[x]]), source=x))
gha97.lbl <- rbindlist(gha97.lbl)
gha97.lbl <- unique(gha97.lbl, by="varCode")
# => we probably need to keep and merge all micro data files from `agg1` to `pov_gh` 
# since these contain many useful constructed vars. Start with `sec0a` to make sure we have
# a complete hhld sample (5998).
gha97.hh <- micro[["sec0a"]]
tmp <- gha97.lbl[source %like% "agg" | source %like% "exp" | source %like% "pov_gh" | source %like% "inc"][!(source %like% "sub" | source %in% paste0("inc", 1:5) | varCode %in% names(gha97.hh))]

# Verify unique hhld ids across datasets
uniqueN(gha97.hh, by=c("eanum", "nh"))
# [1] 5998
sapply(unique(tmp$source), function(x) uniqueN(micro[[x]], by=c("clust", "nh")))
# => note that only few tables contain a full sample

# Keep only household-level vars from the raw data
tmp.dt <- which(sapply(micro, function(x) anyDuplicated(x, by=c("clust", "nh")))==0)
tmp.dt <- names(tmp.dt)
tmp <- tmp[source %in% tmp.dt]

gha97.hh[, .(range(eanum), range(nh))]
#     V1 V2
# 1:   2  1
# 2: 999 25

micro$inc16[, .(range(clust), range(nh))]
#      V1 V2
# 1: 4002  1
# 2: 4999 25

# Recode `eanum` in `sec0a` to match codes used in other aggregates datasets
gha97.hh[, clust := 4000 + eanum]
uniqueN(gha97.hh, by=c("clust", "nh"))
# [1] 5998

# Merge all household-level vars into `gha97.hh`
setkey(gha97.hh, clust, nh)
for (i in unique(tmp$source)) {
  setkey(micro[[i]], clust, nh)
  gha97.hh <- micro[[i]][, .SD, .SDcols=c("clust", "nh", tmp[source==i, varCode])][gha97.hh]
}

# Keep a few extra constructed vars
gha97.prod <- prod
gha97.input <- inputs
# Also save this subset of RIGA vars
gha97.inc <- riga[[2]]

# Clean up GLSS4
rm(i, x, hh, prod, inputs, riga, tmp, tmp.dt, micro)


#####################################################################################
# Income and Sales derived from RIGA Components
#####################################################################################
# Another approach is to explore RIGA sales and income aggregates for the last 3
# rounds of Ghana GLSS. Refer to RIGA documentation for decomposition details.
# Use the following nomenclature (note some of these vars are still net and may be 
# negative, e.g. selfemp, and selfimp):
# - cropsales = totcropsold
# - cropvalue = totcropprod
# - cropsales_sh = cropsales/cropvalue (should compare with `shagprodsold`)
# - agsales = totagsold 
# - aggross = totagprod + farmrntimp + agr_wge + selfimp1 (farm)
# - naggross = transfersgrossimp + otherincimp + nonfarmrntimp + nonagr_wge + selfemp (non-farm)
# - totgross = aggross + naggross
# - aggross_sh = aggross/totgross

vars.char <- c("totcropprod", "totcropsold", "totagprod", "totagsold", "totlvstprod",
"totlivsold", "agowncons", "agmisc", "shagprodsold", "shagowncons",
"shagmisc", "shcropsold", "shlvstsold")

vars.inc <- c("farmrntimp", "agr_wge", "selfimp1", "transfersgrossimp", "otherincimp", 
  "nonfarmrntimp", "nonagr_wge", "selfemp",
  "cropincome1grossimp", "cropincome2grossimp", "livestockgrossimp") 

##########################################
# GLSS6-RIGA

gha12 <- gha12.hh[, .(hhid=HID, nh, clust, region, district, rural=tolower(loc2), year, month, weight)]

### SALES
tmp <- read.dta("~/Projects/hc-data/GHA-GLSS6/riga/Ghana13_HHCHAR_V12.dta")
tmp.lbl <- data.table(varCode=names(tmp), varLabel=attr(tmp, "var.labels"))
gha12.lbl <- rbind(gha12.hh.lbl, gha12.inc.lbl, tmp.lbl)
gha12.lbl <- unique(gha12.lbl, by="varCode")
rm(gha12.hh.lbl, gha12.inc.lbl, tmp.lbl)

tmp <- data.table(tmp)
anyDuplicated(tmp, by="hh")
# => `hh` is unique
tmp[, summary(hh)]
#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
# 6000000 6030000 6061000 6061000 6091000 6120000
gha12[, range(hhid)]
# [1] "60001/01" "61200/15"

# Recode `hhid`
gha12[, hhid := as.integer(str_replace_all(hhid, "/", ""))]
gha12[, summary(hhid)]
#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
# 6000000 6030000 6061000 6061000 6091000 6120000 

# Merge RIGA sales
setkey(tmp, hh)
setkey(gha12, hhid)
gha12 <- tmp[, .SD, .SDcols=-c("district")][gha12]
setnames(gha12, "hh", "hhid")

### INCOME
tmp <- read.dta("~/Projects/hc-data/GHA-GLSS6/riga/Ghana13_HH_INCOME_V12.dta")
tmp.lbl <- data.table(varCode=names(tmp), varLabel=attr(tmp, "var.labels"))
gha12.lbl <- rbind(gha12.lbl, tmp.lbl)
gha12.lbl <- unique(gha12.lbl, by="varCode")

tmp <- data.table(tmp)
anyDuplicated(tmp, by="hh")
# => `hh` is unique
tmp[, summary(hh)]
#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
# 6000000 6030000 6061000 6061000 6091000 6120000

# Merge RIGA incomes
setkey(tmp, hh)
setkey(gha12, hhid)
gha12 <- tmp[, .SD, .SDcols=c("hh", vars.inc)][gha12]
setnames(gha12, "hh", "hhid")

# Then are we sure that RIGA includes aggregates for urban hhlds?
gha12[, .(
  sum(nonagr_wge, na.rm=T),
  sum(agr_wge, na.rm=T)
), by=rural]
#    rural       V1       V2
# 1: urban 17692329 462277.4
# 2: rural  6250761 632194.5
# => looks okay


##########################################
# GLSS5-RIGA

gha05 <- gha05.hh[, .(nh, clust, region, district, rural=tolower(loc2), year, month, weight)]
anyDuplicated(gha05.hh, by=c("clust", "nh"))
gha05[, hhid := clust*100+nh]
anyDuplicated(gha05, by="hhid")

### SALES
tmp <- read.dta("~/Projects/hc-data/GHA-GLSS5/riga/Ghana05_HHCHAR.dta")
tmp.lbl <- data.table(varCode=names(tmp), varLabel=attr(tmp, "var.labels"))
gha05.lbl <- rbind(gha05.hh.lbl, gha05.inc.lbl, tmp.lbl)
gha05.lbl <- unique(gha05.lbl, by="varCode")
rm(gha05.hh.lbl, gha05.inc.lbl, tmp.lbl)

tmp <- data.table(tmp)
anyDuplicated(tmp, by="hh")
# => 17, `hh` is not unique (!!)
# Keep records with higher `totagprod`
setorder(tmp, -totagprod)
tmp <- unique(tmp, by="hh")
tmp[, summary(hh)]
#   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
# 500100  514600  529100  529100  543600  558000 
gha05[, range(hhid)]
# [1] 500102 558015

# Merge RIGA sales
setkey(tmp, hh)
setkey(gha05, hhid)
gha05 <- tmp[, .SD, .SDcols=-c("district")][gha05]
setnames(gha05, "hh", "hhid")

### INCOME
tmp <- read.dta("~/Projects/hc-data/GHA-GLSS5/riga/Ghana05_HH_INCOME.dta")
tmp.lbl <- data.table(varCode=names(tmp), varLabel=attr(tmp, "var.labels"))
gha05.lbl <- rbind(gha05.lbl, tmp.lbl)
gha05.lbl <- unique(gha05.lbl, by="varCode")

tmp <- data.table(tmp)
anyDuplicated(tmp, by="hh")
# => `hh` is unique
tmp[, summary(hh)]
#   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
# 500100  514600  529100  529100  543600  558000

# Merge RIGA incomes
setkey(tmp, hh)
setkey(gha05, hhid)
gha05 <- tmp[, .SD, .SDcols=c("hh", vars.inc)][gha05]
setnames(gha05, "hh", "hhid")

# Then are we sure that RIGA includes aggregates for urban hhlds?
gha05[, .(
  sum(nonagr_wge, na.rm=T),
  sum(agr_wge, na.rm=T)
), by=rural]
#    rural          V1         V2
# 1: urban 18692204447  706078685
# 2: rural  5271284573 1048522438
# => looks okay


##########################################
# GLSS4-RIGA

gha97 <- gha97.hh[, .(nh, clust, region, district, rural=tolower(loc2), year, month, weight)]
anyDuplicated(gha97.hh, by=c("clust", "nh"))
gha97[, summary(clust)]
# Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
# 4002    4252    4502    4500    4752    4999 
gha97[, summary(nh)]
# Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
# 1.00    6.00   11.00   10.88   16.00   25.00 
gha97[, hhid := clust*100+nh]
anyDuplicated(gha97, by="hhid")

### SALES
tmp <- read.dta("~/Projects/hc-data/GHA-GLSS4/riga/Ghana98_HHCHAR.dta")
tmp.lbl <- data.table(varCode=names(tmp), varLabel=attr(tmp, "var.labels"))
writeLines(knitr::kable(gha97.lbl, format="rst"), "~/Projects/hc-data/GHA-GLSS4/temp/GHA-GLSS4_raw.log")
gha97.lbl <- unique(tmp.lbl, by="varCode")
rm(gha97.hh.lbl, gha97.inc.lbl, tmp.lbl)

tmp <- data.table(tmp)
anyDuplicated(tmp, by="hh")
tmp[, summary(hh)]
#   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
# 400200  425100  449900  450000  475000  499900 
gha97[, range(hhid)]
# [1] 400201 499920

# Merge RIGA sales
setkey(tmp, hh)
setkey(gha97, hhid)
gha97 <- tmp[gha97]
setnames(gha97, "hh", "hhid")

### INCOME
tmp <- read.dta("~/Projects/hc-data/GHA-GLSS4/riga/Ghana98_HH_INCOME.dta")
tmp.lbl <- data.table(varCode=names(tmp), varLabel=attr(tmp, "var.labels"))
gha97.lbl <- rbind(gha97.lbl, tmp.lbl)
gha97.lbl <- unique(gha97.lbl, by="varCode")

tmp <- data.table(tmp)
anyDuplicated(tmp, by="hh")
# => `hh` is unique
tmp[, summary(hh)]
#   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
# 400200  425100  449900  450000  475000  499900

# Merge RIGA incomes
setkey(tmp, hh)
setkey(gha97, hhid)
gha97 <- tmp[, .SD, .SDcols=c("hh", vars.inc)][gha97]
setnames(gha97, "hh", "hhid")

# Then are we sure that RIGA includes aggregates for urban hhlds?
gha97[, .(
  sum(nonagr_wge, na.rm=T),
  sum(agr_wge, na.rm=T)
), by=rural]
#    rural         V1        V2
# 1:     2  903291234 126182173
# 2:     1 1732925339  68048954
# => looks okay


#####################################################################################
# Combine all waves
#####################################################################################
# Var names should match now across waves so we can easily rbind()
# `gha97` has fewer vars (87 instead of 92), which ones are missing?
setdiff(names(gha12), names(gha05))
# [1] "landlend"
setdiff(names(gha12), names(gha97))
# [1] "landshare"     "telephone"     "cellphone"     "disthsrschool" "distpubphone"  "TLU_small"    
# [7] "landlend" 

# Can these missing vars be founs elsewhere?
# Remove `landlend` it's not labelled
gha12[, landlend := NULL]
setnames(gha97, "disthgschool", "disthsrschool")
setnames(gha97, "TLU_smallan", "TLU_small")

# Add wave info
gha12[, `:=`(svyCode="gha-glss6", wave=6)]
gha05[, `:=`(svyCode="gha-glss5", wave=5)]
gha97[, `:=`(svyCode="gha-glss4", wave=4)]

gha <- rbind(gha12, gha05, gha97, fill=T)
gha[, distsecschool := NULL]
setkey(gha12.lbl, varCode)
gha.lbl <- gha12.lbl[names(gha)]
gha.lbl[is.na(varLabel)]
#          varCode varLabel
# 1:          hhid       NA
# 2:         rural       NA
# 3:       svyCode       NA
# 4:          wave       NA
gha.lbl[is.na(varLabel), "varLabel"] <- c("unique hhld id", "rural/urban", "survey code", "survey round")

gha[, sum(distsecschool, na.rm=T), by=wave]
#    wave   V1
# 1:    6    0
# 2:    5    0
# 3:    4 5617

# Clean up
rm(gha12, gha05, gha97)

# Do we have a consistent var for cultivated area?
# => no, only `landown`, `landshare` and `landrent` (rented out)

# Import harmonized panel vars from HarvestChoice Resilience Study (to get
# cultivated area)
gha.xtra <- read.dta("~/Projects/ssa-geospat/tmp/Combined_4_Mel.12.dta")
gha.xtra.lbl <- data.table(varCode=names(gha.xtra), varLabel=attr(gha.xtra, "var.labels"))
gha.xtra <- data.table(gha.xtra)
gha.xtra <- gha.xtra[ISO3=="GHA"]
gha.xtra <- gha.xtra[, .SD, .SDcols=1:which(names(gha.xtra)=="privtrans_ppp")]

# Fix a few factor vars
gha.xtra[, survey := factor(survey, 
  lev=c("GLSS12", "GLSS05", "GLSS98"), lab=c("gha-glss6", "gha-glss5", "gha-glss4"))]
gha.xtra[, rural := factor(rural, lev=c(1,0), lab=c("rural", "urban"))]

gha.xtra.lbl[varCode %like% "land"]
#       varCode                                             varLabel
# 1:    landown                              Size of land owned (Ha)
# 2:    landcul                         Size of land cultivated (Ha)
# 3: landfallow                  hectares land owned and left fallow
# 4:   landfall                     Size of land left fallowing (Ha)
# 5:   landpast                   Size of land used for pasture (Ha)
# 6:    landoth hectares land owned and used for forest or other use
# 7:   ilandown                     hectares of irrigated land owned

gha.xtra[, 100*sum(landcul>0, na.rm=T)/.N, by=year]
#    year        V1
# 1: 2006 60.505031
# 2: 2005 54.256495
# 3: 2012 51.680048
# 4: 2013 52.994258
# 5: 1998  9.778161
# 6: 1999  5.977797
# => does not look good for GLSS4

gha.xtra[, 100*sum(landown>0, na.rm=T)/.N, by=year]
#    year        V1
# 1: 2006  37.38410
# 2: 2005  38.69541
# 3: 2012 100.00000
# 4: 2013  98.49355
# 5: 1998  28.14990
# 6: 1999  24.50897

gha[, 100*sum(rowSums(.SD[, .(landown, -landrent)], na.rm=T)>0, na.rm=T)/.N, by=year]
#    year       V1
# 1: 2012 43.64558
# 2: 2013 42.24292
# 3: 2006 50.79583
# 4: 2005 52.52918
# 5:   98 26.94873
# 6:   99 21.75000
# => best to use this approach for `croparea`

# Recode year
gha[year==98, year := 1998]
gha[year==99, year := 1999]

# Recode rural
gha[rural=="1", rural := "urban"]
gha[rural=="2", rural := "rural"]

gha[, summary(weight)]
#  Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
# 0.127  113.600  338.000  386.100  571.900 3476.000 
# => OK

#####################################################################################
# Geographic Stratification
#####################################################################################
# Add and harmonize strata vars across all waves 
# Forgot to include `ez`, `loc5`, and to recode `region` and `district`
# We should also make sure that `region` and `district` can be mapped (done for DSG in 2016)
# Maybe also add XY district centroids, since we have no usable GPS coords.
rm(list=ls())
load("./tmp/2017-agra-aasr_GHA_waves.RData")
load("./tmp/2017-agra-aasr_GHA_merged.RData")

# GLSS4 Recodes
# --- ez
# 1 Coastal
# 2 Forest
# 3 Savannah
# --- loc5
# 1 Accra
# 2 Other Urban
# 3 Rural Coastal
# 4 Rural Forest
# 5 Rural Savannah
# --- loc3
# 1 Accra
# 2 Other Urban
# 3 Rural
# --- region
# 1 Western
# 2 Central
# 3 Greater Accra
# 4 Eastern
# 5 Volta
# 6 Ashanti
# 7 Brong Ahafo
# 8 Northern
# 9 Upper East
# 10 Upper West

levels(gha$region)
#  [1] "Western"       "Central"       "Greater Accra" "Volta"         "Eastern"       "Ashanti"      
#  [7] "Brong Ahafo"   "Northern"      "Upper East"    "Upper West"    "western"       "central"      
# [13] "greater accra" "volta"         "eastern"       "ashanti"       "brong ahafo"   "northern"     
# [19] "upper east"    "upper west"    "1"             "2"             "3"             "5"            
# [25] "4"             "6"             "7"             "8"             "9"             "10" 

levels(gha$region) <- c(
"Western"       ,"Central"       ,"Greater Accra" ,"Volta"         ,"Eastern"       ,"Ashanti"      
,"Brong Ahafo"   ,"Northern"      ,"Upper East"    ,"Upper West"    ,"Western"       ,"Central"      
,"Greater Accra" ,"Volta"         ,"Eastern"       ,"Ashanti"       ,"Brong Ahafo"   ,"Northern"     
,"Upper East"    ,"Upper West"    ,"Western"       ,"Central"      ,"Greater Accra"  ,"Volta"            
,"Eastern"       ,"Ashanti"      ,"Brong Ahafo"    ,"Northern"     ,"Upper East"     ,"Upper West")

table(gha$region)
#  Western       Central Greater Accra         Volta       Eastern       Ashanti   Brong Ahafo 
#     3191          2991          4040          3114          3358          4615          2956 
# Northern    Upper East    Upper West 
#     2857          2167          2168 

# Merge in `ez` and `loc5`
setkey(gha97.hh, clust, nh)
setkey(gha, clust, nh)
gha[gha97.hh, `:=`(ez=as.character(i.ez), loc5=as.character(i.loc5))]
gha[, table(ez)]
gha[, table(loc5)]
  
gha[ez=="1", ez := "Coastal"]
gha[ez=="2", ez := "Forest"]
gha[ez=="3", ez := "Savannah"]

gha[loc5=="1", loc5 := "Accra"]
gha[loc5=="2", loc5 := "Other Urban"]
gha[loc5=="3", loc5 := "Rural Coastal"]
gha[loc5=="4", loc5 := "Rural Forest"]
gha[loc5=="5", loc5 := "Rural Savannah"]

gha05.hh[, .(aez, ez, loc5, loc7)]
setkey(gha05.hh, clust, nh)
setkey(gha, clust, nh)
gha[gha05.hh, `:=`(ez=i.ez, loc5=i.loc5)]
gha[, table(ez)]
gha[, table(loc5)]

# GLSS5 Recodes
# `loc5` is not found in metadata so assume same as GLSS4
gha[loc5=="1", loc5 := "Accra"]
gha[loc5=="2", loc5 := "Other Urban"]
gha[loc5=="3", loc5 := "Rural Coastal"]
gha[loc5=="4", loc5 := "Rural Forest"]
gha[loc5=="5", loc5 := "Rural Savannah"]

gha[, table(loc5)]
# loc5
#  Accra    Other Urban  Rural Coastal   Rural Forest Rural Savannah 
#   1727           4090           1769           4085           3014 
          
gha12.hh[, .(ez, loc5, loc7)]
setkey(gha12.hh, clust, nh)
setkey(gha, clust, nh)
gha[gha12.hh, `:=`(ez=i.ez, loc5=i.loc5)]
gha12.hh[, table(ez)]
gha[, table(ez)]
gha[, table(loc5)]

# GLSS6 Recodes
gha[ez=="savannah", ez := "Savannah"]
gha[ez=="forest", ez := "Forest"]
gha[ez=="coastal", ez := "Coastal"]

gha[loc5=="Accra (GAMA)", loc5 := "Accra"]
gha[loc5=="Other Urban ", loc5 := "Other Urban"]

# Verify
gha[, sum(is.na(ez)), by=wave]
#    wave V1
# 1:    4  0
# 2:    5  0
# 3:    6  0

gha[, sum(is.na(loc5)), by=wave]
#    wave V1
# 1:    4  0
# 2:    5  0
# 3:    6  0

# Convert all to clean factors
gha[, rural := factor(rural, lev=c("rural", "urban"))]
gha[, ez := factor(ez, lev=c("Coastal", "Forest", "Savannah", "GAMA"))]
gha[, region := factor(region, lev=c("Western", "Central", "Greater Accra", "Eastern", 
  "Volta", "Ashanti", "Brong Ahafo", "Northern", "Upper East", "Upper West"))]
gha[, svyCode := factor(svyCode, lev=c("gha-glss6", "gha-glss5", "gha-glss4"))]
gha[, wave := factor(wave, lev=c(6,5,4), lab=c("wave 6", "wave 5", "wave 4"))]
gha[, year := as.integer(year)]
gha[, month := as.integer(month)]
gha[, date := as.Date(paste(year, month, "01", sep="-"))]

##########################################
# Recode survey districts
# Merge in labels from Beliyou's `gha.xtra`
# => Beliyou seems to have dropped the raw ids in `hhid_merge`, not sure I can merge
# )-: and in Sara's poverty data files I only have GLSS6
# Load all survey district maps instead (from the work done for HarvestChoice)
g2 <- shapefile("~/Projects/hc-data/_global_codes/out/r16.12/svyL2Maps_2016.12.shp")

# Keep Ghana
g2 <- g2[g2$ISO3=="GHA",]

# Verify codification
g2.dt <- data.table(g2@data)
g2.dt[, rn := row.names(g2)]
table(g2.dt$svyCode)
g2.dt[, svyCode := factor(svyCode, lev=c("gha2005", "gha2012"), lab=c("gha-glss5", "gha-glss6"))]
# => GLSS4 is missing
table(g2.dt$svyL1Nm)
g2.dt[, svyL1Nm := factor(svyL1Nm)]
levels(g2.dt$svyL1Nm) <- c(
"Ashanti", "Ashanti", "Brong Ahafo", "Brong Ahafo", "Central", "Central", "Eastern", "Eastern", "Greater Accra", "Greater Accra", "Northern", "Northern", "Upper East", "Upper East", "Upper West", "Upper West", "Volta", "Volta", "Western", "Western")

anyDuplicated(g2.dt, on="svyL2Nm")
setkey(g2.dt, svyCode, svyL1Nm, svyL2Cd)
setkey(gha, svyCode, region, district)
gha[g2.dt, `:=`(svyL2Cd=i.svyL2Cd, svyL2Nm=i.svyL2Nm, prttyNm=i.prttyNm)]
gha[is.na(svyL2Cd), .N, by=svyCode]
#      svyCode    N
# 1: gha-glss4 5998
# => all merged aside from GLSS4, good!

# Also add XY
gha[g2.dt, `:=`(X=i.X, Y=i.Y)]

# TODO Generate a GLSS4 district map
# There must be one done for Beliyou's resilience study
rm(list=ls())
load("~/Projects/ssa-geospat/tmp/resilience.RData")
unique(g2$svyCode)
# => no, there's no map for GLSS4



# Map dominant region and AEZ to make sure everything is correct
tmp <- gha[, .(ez=modal(ez, na.rm=T)), keyby=.(svyCode, region, svyL2Cd)]
setkey(g2.dt, svyCode, svyL1Nm, svyL2Cd)
g2.dt[tmp, ez := i.ez]

# Update complete map with corrected attributes
g2 <- SpatialPolygonsDataFrame(g2, data.frame(g2.dt), match.ID="rn")

spplot(g2[g2$svyCode=="gha-glss5",], zcol="ez")
# => 3 districts that look a little dubious
spplot(g2[g2$svyCode=="gha-glss6",], zcol="ez")
# => OK


##################################################################################### 
# Farm Typology 
#####################################################################################
# Search for a sensible cultivated area in the raw data files
rm(list=ls())
load("./tmp/2017-agra-aasr_GHA_waves.RData")
# => does not exist and not in `gha98_usaid.dta` either

# CULTIVATED AREA
# See discussion below, we settle for using RIGA operated area
gha[, croparea := NULL]
gha[, croparea := rowSums(.SD[, .(landown, landshare, -landrent)], na.rm=T)]
gha[, 100*sum(croparea > 0 & croparea <= 4, na.rm=T)/.N, by=.(wave, rural)]
#    wave rural        V1
# 1:    6 urban 15.768972
# 2:    6 rural 47.389300
# 3:    5 urban 19.983416
# 4:    5 rural 53.580588
# 5:    4 rural 24.848644
# 6:    4 urban  7.958163

gha[, 100*sum(croparea > 4, na.rm=T)/.N, by=.(wave, rural)]
#    wave rural        V1
# 1:    6 urban  3.317663
# 2:    6 rural 13.841535
# 3:    5 urban  4.588170
# 4:    5 rural 17.163149
# 5:    4 rural  9.818373
# 6:    4 urban  2.819463

# SHF 4ha dummy `croparea_clas` (3-class)
gha[, croparea_clas := NULL]
gha[, max(croparea, na.rm=T)]
gha[croparea>0, croparea_clas := cut(croparea, c(-1,2,4,110), labels=c("<= 2 ha", "2-4 ha", "> 4 ha"), ordered=T, right=F)]
summary(gha$croparea_clas)
# <= 2 ha  2-4 ha  > 4 ha    NA's 
#    6597    3555    3009   18296 

# There are 5512 hlds with some crop production but no land
# I'm tempted to impute `croparea` in those cases
gha[, sum(totcropprod>0, na.rm=T), by=croparea_clas]
#   croparea_clas   V1
# 1:            NA 5512
# 2:       <= 2 ha 4951
# 3:        2-4 ha 3025
# 4:        > 4 ha 2558

# What is the median crop production per ha per survey. Use that to impute `croparea`.
gha[, totcropprod_ha := median(ifelse(totcropprod==0, NA, totcropprod)/croparea, na.rm=T), by=svyCode]
gha[, croparea_imp := croparea]
gha[totcropprod>0 & (is.na(croparea) | croparea==0), croparea_imp := totcropprod/totcropprod_ha]
# => some issues with GLSS4, can't use this approach
gha[, croparea_q1 := median(ifelse(croparea==0, NA, croparea), na.rm=T), by=.(svyCode, region)]
gha[totcropprod>0 & (is.na(croparea_imp) | croparea_imp==0), croparea_imp := croparea_q1]

# SHF 4ha dummy `croparea_clas` (3-class) -- imputed
gha[, croparea_clas := NULL]
gha[, max(croparea_imp, na.rm=T)]
gha[croparea_imp>0, croparea_clas := cut(croparea_imp, c(-1,2,4,110), labels=c("<= 2 ha", "2-4 ha", "> 4 ha"), ordered=T, right=F)]
summary(gha$croparea_clas)
# <= 2 ha  2-4 ha  > 4 ha    NA's 
#   10788    4398    3487   12784

# There are still 226 hlds with some `shagprodsold` but no land (in all 3 surveys)
# I'm tempted to impute `croparea` again
gha[, sum(shagprodsold>0, na.rm=T), by=croparea_clas]
#    croparea_clas   V1
# 1:            NA  226
# 2:       <= 2 ha 6265
# 3:        2-4 ha 4136
# 4:        > 4 ha 2705

# Impute inconsistent `croparea` using median `croparea_imp` per survey and per tercile of
# `shagprodsold`
gha[, shagprodsold_na := ifelse(shagprodsold==0, NA, shagprodsold)]
gha[, shagprodsold_q3 := as.character(cut2(shagprodsold_na, g=3)), by=svyCode]
gha[, croparea_q1 := median(ifelse(croparea_imp==0, NA, croparea_imp), na.rm=T), by=shagprodsold_q3]
gha[shagprodsold>0 & (is.na(croparea_imp) | croparea_imp==0), croparea_imp := croparea_q1]

# SHF 4ha dummy `croparea_clas` (3-class) -- imputed
gha[, croparea_clas := NULL]
gha[, max(croparea_imp, na.rm=T)]
gha[croparea_imp>0, croparea_clas := cut(croparea_imp, c(-1,2,4,226), labels=c("<= 2 ha", "2-4 ha", "> 4 ha"), ordered=T, right=F)]
summary(gha$croparea_clas)
# <= 2 ha  2-4 ha  > 4 ha    NA's 
#   10084    5503    3312   12558 
# => OK

# Clean up intermediary vars
gha[, `:=`(totcropprod_qtl=NULL, shagprodsold_na=NULL, shagprodsold_q3=NULL, 
  croparea_q1=NULL, totcropprod_ha=NULL)]

# HHlds with crop share but no/null aggross?
gha[shagprodsold>0, .N, by=aggross>0]
#    aggross     N
# 1:    TRUE 13332
# => OK

gha[aggross>0, .N, by=shagprodsold>0]
#    shagprodsold     N
# 1:         TRUE 13332
# 2:        FALSE  3433

##########################################
# Construct other missing typology vars, using RIGA components:
# - cropsales = totcropsold
# - cropvalue = totcropprod
# - cropsales_sh = cropsales/cropvalue (but can compare with `shagprodsold`)
# - agsales = totagsold 
# - aggross = totagprod + farmrntimp + agr_wge + selfimp1 (farm)
# - naggross = transfersgrossimp + otherincimp + nonfarmrntimp + nonagr_wge + selfemp (non-farm)
# - totgross = aggross + naggross
# - naggross_sh = naggross/totgross
vars <- c("totcropsold", "totcropprod", "shagprodsold", "totagsold", "totagprod",
  "farmrntimp", "agr_wge", "selfimp1", 
  "transfersgrossimp", "otherincimp", "nonfarmrntimp", "nonagr_wge", "selfemp")

# Summarize all these vars across waves
tmp <- gha[, lapply(.SD, summary), .SDcols=vars, by=wave]
sapply(gha[, .SD, .SDcols=vars], class)
# => `selfimp1` and `selfemp` have negative values
gha.lbl[varCode %in% c("selfimp1", "selfemp"), varLabel]
# [1] "Net HH Income from Non-Ag Business- Agr, Fishing, Imptd" => ignore completely
# [2] "Annual net nonfarm self employment income, imputed" => impute negative to NA


# CROP PRODUCTION
summary(gha$totcropprod)
# => too many missing!!
gha[, sum(is.na(totcropprod)), by=svyCode]
gha[, sum(is.na(shagprodsold)), by=svyCode]
gha[, median(totcropprod, na.rm=T), by=croparea_clas]
# => some hhlds have no/missing land but some crop production
#    croparea_clas        V1
# 1:            NA  364.9028
# 2:       <= 2 ha 2663.6998
# 3:        2-4 ha 3150.7749
# 4:        > 4 ha 9092.4375
gha[, cropvalue := totcropprod]

# CROP SALES
summary(gha$totcropsold)
gha[, median(totcropsold, na.rm=T), by=croparea_clas]
#    croparea_clas   V1
# 1:            NA    0
# 2:       <= 2 ha  270
# 3:        2-4 ha 1240
# 4:        > 4 ha 3883
# => seems land consistent
gha[, cropsales := totcropsold]
gha[, cropsales_sh := cropsales/cropvalue]
gha[, summary(cropsales_sh)]
#  Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
# 0.000   0.000   0.254   0.336   0.601   1.000   15411 
gha[, summary(shagprodsold)]
#   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
# 0.0000  0.0000  0.0000  0.1998  0.3545  1.0000     310 
# => probably just more 0
gha[cropsales_sh>0, .N, by=svyCode]
gha[shagprodsold>0, .N, by=svyCode]
# => more positive obs if using `shagprodsold`
gha[, cropsales_sh := shagprodsold]

# TOTAL AG SALES
summary(gha$totagsold)
gha[, median(totagsold, na.rm=T), by=croparea_clas]
#    croparea_clas     V1
# 1:            NA    0.0
# 2:       <= 2 ha  622.0
# 3:        2-4 ha 1723.0
# 4:        > 4 ha 5069.5
gha[, agsales := totagsold]
gha[agsales>0, .N, by=svyCode]

# GROSS FARM INCOME
summary(gha$farmrntimp)
summary(gha$agr_wge)
summary(gha$selfimp1)
# => ignore `selfimp1` for now
gha[, aggross := rowSums(.SD[, .(totagprod, farmrntimp, agr_wge)], na.rm=T)]
gha[aggross>0, .N, by=svyCode]

# GROSS NON-FARM INCOME
summary(gha$transfersgrossimp)
summary(gha$otherincimp)
summary(gha$nonfarmrntimp)
summary(gha$nonagr_wge)
summary(gha$selfemp)
gha[, summary(ifelse(selfemp < 0, NA, selfemp))]
# => not too many negatives, only 2,200, and mostly in GLSS5 (??)
boxplot(selfemp~svyCode, gha)
gha[, naggross := rowSums(.SD[, .(transfersgrossimp, otherincimp, nonfarmrntimp, nonagr_wge, ifelse(selfemp < 0, NA, selfemp))], na.rm=T)]
gha[, totgross := rowSums(.SD[, .(aggross, naggross)], na.rm=T)]
gha[, naggross_sh := naggross/totgross]
gha[, summary(naggross_sh), by=svyCode]

gha[, sum(cropsales_sh>0, na.rm=T), by=croparea_clas]
#    croparea_clas   V1
# 1:            NA 3792
# 2:       <= 2 ha 3291
# 3:        2-4 ha 2494
# 4:        > 4 ha 2308
# => imputed:
#    croparea_clas   V1
# 1:            NA    0
# 2:       <= 2 ha 6269
# 3:        2-4 ha 4358
# 4:        > 4 ha 2705

gha[, sum(naggross_sh>0, na.rm=T), by=croparea_clas]
# => imputed:
#    croparea_clas    V1
# 1:            NA 10244
# 2:       <= 2 ha  6595
# 3:        2-4 ha  3343
# 4:        > 4 ha  1990

##########################################
# SHF 4ha dummy `croparea_4ha` (2-class)
gha[, croparea_4ha := NULL]
gha[croparea_imp>0, croparea_4ha := factor(croparea_imp <= 4, levels=c(T, F), labels=c("<= 4 ha", "> 4 ha"))]
summary(gha$croparea_4ha)
# <= 4 ha  > 4 ha    NA's 
#   15587    3312   12558 

##########################################
# Crop commercialization dummy `cropsales_clas` (3-class)
gha[, cropsales_clas := NULL]
gha[, cropsales_clas := cut(cropsales_sh, c(-1,.05,.5,1.1), labels=c("LoC", "MeC", "HiC"), ordered=T, right=F)]
summary(gha$cropsales_clas)
#   LoC   MeC   HiC  NA's 
# 18750  6452  5945   310 

##########################################
# Income diversification dummy `noaggross_clas` (3-class)
gha[, naggross_clas := NULL]
gha[, naggross_clas := cut(naggross_sh, c(-1,1/3,2/3,1.1), labels=c("LoD", "MeD", "HiD"), ordered=T, right=F)]
summary(gha$naggross_clas)
#   LoD   MeD   HiD  NA's 
# 10549  1934 16268  2706 

##########################################
# Classification dummy `` (9-class)
class9 <- c("LoCLoD", "LoCMeD", "LoCHiD",  "MeCLoD", "MeCMeD", "MeCHiD", 
  "HiCLoD", "HiCMeD", "HiCHiD")
gha[, class9 := NULL]
gha[, class9 := factor(paste0(cropsales_clas, naggross_clas), levels=class9)]
summary(gha$class9)
# LoCLoD LoCMeD LoCHiD MeCLoD MeCMeD MeCHiD HiCLoD HiCMeD HiCHiD   NA's 
#   2400    500  13454   4387    752   1313   3762    682   1501   2706 


```


```{r gha-save, eval=FALSE}

#####################################################################################
# Save constructed vars for all individual waves
#save.image("./tmp/2017-agra-aasr_GHA_waves.RData")

# Keep only combined datasets
save(g2, gha, gha.lbl, gha.xtra, gha.xtra.lbl, vars.inc, vars.char,
  file="./tmp/2017-agra-aasr_GHA_merged.RData")

# Save workspace
rm(tmp, tmp.lbl, i, x)
save.image("./tmp/2017-agra-aasr_GHA.RData")

```

Relevant sources of household-level micro records for Ghana are the **6 rounds of Ghana Living Standards Surveys** in particular:

- 1998/1999 **GLSS4** (EAs were first stratified into 3 ecological zones (Coastal, Forest, Savannah), and then within each zone further stratification was done into rural or urban areas)
- 2005/2006 **GLSS5** (EAs were first stratified into 10 administrative regions; within each region EAs were further sub-divided into rural or urban areas; EAs were also classified into  ecological zones and inclusion of Accra (GAMA) so that the survey results may be presented across 1) Coastal, 2) Forest, and 3) Northern Savannah, and 4) Accra).
- 2012/2013 **GLSS6** (EAs were allocated into 10 regions using probability proportional to population size (PPS), then further divided into urban and rural localities).

In contrast to the latest 2 waves GLSS4 is only representative for 3 (ecology) x 2 (rural/urban) zones.

GLSS collect information on the demographic characteristics of the population, their education, health, employment and time use, migration, housing conditions and household agriculture, with a specific focus on **labour force**, with a labour force module expanded in GLSS6 to include a section on child labour.

```{r, gha-samples}

tmp <- data.frame(
  Survey=c("GLSS4", "GLSS5", "GLSS6"),
  Year=c("1997/98", "2005/06", "2012/13"),
  Regions=c(10, 10, 10),
  Districts=c(102, 110, 170),
  `Sample`=c(5998, 8687, 16772),
  `Urban`=c(2199, 3618, 7445),
  `Rural`=c(3799, 5069, 9327))

kable(tmp,
  justify="ccrrrrrrrr", format.args=list(big.mark=","),
  caption="Composition of GLSS Survey Samples")

```

RIGA aggregates were used to estimate both crop sales and farm vs. non-farm income. Generally in the RIGA approach the method is (see @riga2007doco):

- All aggregates are estimated at the household level.  
- All income and expenditures are **annualized**.  
- All income components are **net of costs**.  
- Purchases and sales of **durable goods**, investments and windfall gains are excluded from household income and expenditure calculations since these are not transactions undertaken regularly by households and can result in the significant over- or under-stating of permanent income.  
- All aggregates are reported in **local currency units**.  
- For each survey, only the **rural** sample is used (to be verified)  
- An outlier check was imposed after the construction of the income aggregate to deal with extreme income shares that arose following the aggregation of all income components. After estimating the shares of the seven principal income categories (agricultural wages, non-agricultural wages, crop, livestock, self employment, transfer and other) **observations whose share was greater than or less than 3 (indicating a percentage share of +/- 300%) were dropped from the aggregate**.  

Because RIGA income aggregates are *net of costs*, we used the following components instead:

- $cropsales$ derived from $totcropsold$
- $cropvalue$ derived from $totcropprod$
- $cropsales\_sh$ (but can also be derived from $shagprodsold$)
  $$ cropsales\_sh = \frac{cropsales}{cropvalue} $$ 
- $agsales$ derived from $totagsold$
- $aggross = totagprod + farmrntimp + agr\_wge + selfimp1$
- $naggross = transfersgrossimp + otherincimp + nonfarmrntimp + nonagr\_wge + selfemp$
- $totgross = aggross + naggross$  
- $aggross\_sh$  
  $$ aggross\_sh = \frac{aggross}{totgross} $$  

### Cultivated Area

RIGA does not provide annual cultivated area, instead we have measures of land owned, land rented out, and land under sharecropping. IFPRI/HarvestChoice produced pseudo-panel variables $landcul$ and $landown$ (but the results look a little dubious for GLSS4, see \@ref(tab:tabcultareahh) below). Using operated area derived from RIGA instead (i.e. $croparea=landown+landshare-landrent$) does yield higher proportions of households for GLSS4 but lower for GLSS6. In general GLSS4 seems to exhibit poorer data quality.

```{r gha-cultarea, results="asis"}

tmpha <- gha.xtra[, 100*sum(landcul>0, na.rm=T)/.N, keyby=.(year, rural)]
tmphb <- gha.xtra[, 100*sum(landown>0, na.rm=T)/.N, keyby=.(year, rural)]
tmpr <- gha[, 100*sum(rowSums(.SD[, .(landown, landshare, -landrent)], na.rm=T)>0, na.rm=T)/.N, keyby=.(year, rural)]

tmpha[, Source := "IFPRI (landcult)"]
tmphb[, Source := "IFPRI (landown)"]
tmpr[, Source := "RIGA"]
tmp <- rbind(tmpha, tmphb, tmpr)

table_options(HTMLcaption="(#tab:tabcultareahh) Proportions of sampled households with any cultivated area across survey years (mutliple sources shown)")
html(tabular((`Year`=Factor(year))~Heading("Percent oh Hhlds with Cultivated Area")*V1*Heading()*Factor(Source)*Heading()*Factor(rural)*Heading()*Format(digits=2)*identity, 
  data=tmp))

```

```{r gha-bplota, fig.cap="Cultivated Area (ha). Source: IFPRI 2016"}

par(mfrow=c(1,2), cex=.9, font.main=1)
for (i in levels(gha.xtra$rural)) boxplot(landcul~survey, gha.xtra[rural==i], 
  main=i, ylim=c(0,7), varwidth=T, outline=F,
  xlab=paste0(gha.xtra[rural==i, round(100*sum(is.na(landcul)|landcul==0)/.N)], "% missing or null"),
  ylab="Cultivated Area (ha)")

```

```{r gha-bplotb, fig.cap="Farm Size (ha). Source: IFPRI 2016"}

par(mfrow=c(1,2), cex=.9, font.main=1)
for (i in levels(gha.xtra$rural)) boxplot(landown~survey, gha.xtra[rural==i], 
  main=i, ylim=c(0,6), varwidth=T, outline=F,
  xlab=paste0(gha[rural==i, round(100*sum(is.na(landown)|landown==0)/.N)], "% missing or null"),   
  ylab="Farm Size (ha)")

```

```{r gha-bplotc, fig.cap="Operated Area (ha). Source: FAO/RIGA"}

par(mfrow=c(1,2), cex=.9, font.main=1)
for (i in levels(gha$rural)) boxplot(rowSums(cbind(landown, landshare, -landrent), na.rm=T)~svyCode, gha[rural==i], 
  main=i, ylim=c(0,7.4), varwidth=T, outline=F,
  xlab=paste0(gha[rural==i, round(100*sum(is.na(croparea)|croparea==0)/.N)], "% missing or null"), 
  ylab="Operated Area (ha)")

```

In the following classification we use **option #3** (FAO/RIGA operated area) across the 3 waves.

```{r gha-areacounts, results="asis"}

table_options(HTMLcaption="(#tab:countsghaa) Count of Observations across Classes of Operated Area")
html(tabular(Heading()*svyCode+1~Heading()*croparea_clas+Heading("N (sample)")*1*Format(digits=0, big.mark=","),
  data=gha))

table_options(HTMLcaption="(#tab:countsghab) Proportions of Observations across Classes of Operated Area (percent of full survey sample)")
html(tabular(Heading()*svyCode+1~Format(digits=0, big.mark=",")*Heading()*croparea_clas*Heading()*Percent(Equal(svyCode)),
  data=gha))

table_options(HTMLcaption="(#tab:countsghac) Proportions of Observations across Classes of Operated Area (percent of selected farm households)")
html(tabular(Heading()*svyCode+1~Format(digits=0, big.mark=",")*(Heading()*croparea_clas+1)*Heading()*Percent(Equal(svyCode)),
  data=gha[!is.na(croparea_clas)]))

```

We further impute cultivated area for households with some amount of crop production and crop sales to ensure internal consistency in the sample (over 5,700 households reported crop sales but no cultivated area). Figure \@ref(fig:gha-bplotareaimputed) below show cultivated area post-imputation.

```{r gha-bplotareaimputed, fig.cap="Cultivated Area (ha) (post-imputation)"}

par(mfrow=c(1,2), cex=.9, font.main=1)
for (i in levels(gha$rural)) boxplot(croparea_imp~svyCode, 
  gha[rural==i], ylim=c(0,7.4), main=i, varwidth=T, outline=F,
  xlab=paste0(gha[rural==i, round(100*sum(is.na(croparea_imp)|croparea_imp==0)/.N)], "% missing or null"), 
  ylab="Operated Area (ha, imputed)")

```


### Crop Commercialization

We evaluate multiple sources (and/or proxies) of aggregate household crop sales (again from FAO/RIGA and separately from IFPRI). Generally RIGA reports *gross* crop production, crop sales, and share of  crop production sold in $totcropprod$, $totcropsold$, and $shcropsold$ respectively. All other relevant variables are listed here:

- $totcropprod$ -- value of total annual crop production
- $totcropsold$ -- value total annual crop production sold
- $totagprod$ -- value total annual agricultural production
- $totagsold$ -- value total annual agricultural production sold
- $totlvstprod$ -- value of total annual livestock production
- $totlivsold$ -- value total annual livestock production sold
- $agowncons$ -- value total annual agricultural production consumed
- $agmisc$ -- value total annual agricultural production- miscellaneous uses
- $shagprodsold$ -- share of annual agricultural production sold in total agricultural production
- $shagowncons$ -- share of annual agricultural production consumed in total agricultural productio
- $shagmisc$ -- share of annual agricultural production misc in total agricultural production
- $shcropsold$ -- share of total annual crop production sold in total crop production
- $shlvstsold$ -- share of total annual livestock production sold in total livestock production
- $cropincome1gross(imp)$ -- gross crop income (crop1)
- $cropincome2gross(imp)$ -- gross crop income (crop2)
- $livestockgross(imp)$ -- gross livestock income

However the quality of these constructed variables for Ghana tends to vary widely across survey years.

```{r gha-bplotsales, fig.cap="Sources of Crop Commercialization (RIGA, IFPRI, author)"}

par(mfrow=c(1,3), cex=.9, font.main=1, cex.lab=.8)
boxplot(I(100*totcropsold/totcropprod)~svyCode, 
  gha[rural=="rural"], ylim=c(0,100), main="rural", varwidth=T, outline=F,
  xlab=paste0(gha[rural=="rural", round(100*sum(is.na(totcropsold/totcropprod)|totcropsold==0)/.N)], "% missing or null"), 
  ylab="Share of Crop Production Sold (%), author")

boxplot(I(100*shcropsold)~svyCode, 
  gha[rural=="rural"], ylim=c(0,100), main="rural", varwidth=T, outline=F,
  xlab=paste0(gha[rural=="rural", round(100*sum(is.na(shcropsold)|shcropsold==0)/.N)], "% missing or null"), 
  ylab="Share of Crop Production Sold (%), RIGA")

boxplot(I(100*shagprodsold)~svyCode, 
  gha[rural=="rural"], ylim=c(0,100), main="rural", varwidth=T, outline=F,
  xlab=paste0(gha[rural=="rural", round(100*sum(is.na(shagprodsold)|shagprodsold==0)/.N)], "% missing or null"), 
  ylab="Share of Ag. Production Sold (%), RIGA")

boxplot(I(100*totcropsold/totcropprod)~svyCode, 
  gha[rural=="urban"], ylim=c(0,100), main="urban", varwidth=T, outline=F,
  xlab=paste0(gha[rural=="urban", round(100*sum(is.na(totcropsold/totcropprod)|totcropsold==0)/.N)], "% missing or null"), 
  ylab="Share of Crop Production Sold (%), author")

boxplot(I(100*shcropsold)~svyCode, 
  gha[rural=="urban"], ylim=c(0,10), main="urban", varwidth=T, outline=F,
  xlab=paste0(gha[rural=="urban", round(100*sum(is.na(shcropsold)|shcropsold==0)/.N)], "% missing or null"), 
  ylab="Share of Crop Production Sold (%), RIGA")

boxplot(I(100*shagprodsold)~svyCode, 
  gha[rural=="urban"], ylim=c(0,10), main="urban", varwidth=T, outline=F,
  xlab=paste0(gha[rural=="urban", round(100*sum(is.na(shagprodsold)|shagprodsold==0)/.N)], "% missing or null"),
  ylab="Share of Ag. Production Sold (%), RIGA")

```

In the following we use RIGA share of crop products sold $shagprodsold$ instead of crop sales.


### Income Diversification

[doco TBD]. 

### Key Results


```{r gha-counts-clas, results="asis"}

table_options(HTMLcaption="(#tab:countsa) Count of Observations across Classes of Farm Households")
html(tabular(Heading(Wave)*svyCode*(Heading()*naggross_clas+1)~Format(digits=0, big.mark=",")*(Heading()*croparea_clas*Heading()*cropsales_clas+1),
  data=gha))

table_options(HTMLcaption="(#tab:countsb) Proportions of Observations across Classes of Farm Households (percent of full survey sample)")
html(tabular(Heading(Wave)*svyCode*(Heading()*naggross_clas+1)~(Heading()*croparea_clas*Heading()*cropsales_clas+1)*Heading()*Format(digits=0, big.mark=",")*Percent(Equal(svyCode)),
  data=gha))

table_options(HTMLcaption="(#tab:countsc) Proportions of Observations across Classes of Farm Households (percent of selected farm households)")
html(tabular(Heading(Wave)*svyCode*(Heading()*naggross_clas+1)~(Heading()*croparea_clas*Heading()*cropsales_clas+1)*Heading()*Format(digits=0, big.mark=",")*Percent(Equal(svyCode)),
  data=gha[!is.na(croparea_4ha) & !is.na(class9)]))

```

    
In the next tables we limit categories to farm households **below/above 4ha** (as this approach produces classes with larger counts of observations). 

```{r gha-counts-4ha, results="asis"}

table_options(HTMLcaption="(#tab:countsd) Count of Observations across Classes of Farm Households (farms above/below 4 ha)")
html(tabular(Heading("Wave")*svyCode*Heading()*(naggross_clas+(`All`=1))~Format(digits=0, big.mark=",")*(Heading()*croparea_4ha*Heading()*cropsales_clas+1),
  data=gha))

table_options(HTMLcaption="(#tab:countse) Proportions of Observations across Classes of Farm Households (farms above/below 4 ha) (percent of full survey sample)")
html(tabular(Heading(Wave)*svyCode*(Heading()*naggross_clas+1)~(Heading()*croparea_4ha*Heading()*(cropsales_clas+1)+1)*Heading()*Format(digits=0, big.mark=",")*Percent(Equal(svyCode)),
  data=gha))

table_options(HTMLcaption="(#tab:countsf) Proportions of Observations across Classes of Farm Households (farms above/below 4 ha) (percent of selected farm households)")
html(tabular(Heading(Wave)*svyCode*(Heading()*naggross_clas+1)~(Heading()*croparea_4ha*Heading()*(cropsales_clas+1)+1)*Heading()*Format(digits=0, big.mark=",")*Percent(Equal(svyCode)),
  data=gha[!is.na(croparea_4ha) & !is.na(class9)]))

```

Using data from the 3 GLSS waves we estimate the proportions of farm households across all categories and the distributions of other key household characteristics (household structure, assets, farm input uses, etc.).

Estimated proportions of farm households across classes and categories are shown in the next graph and table.

```{r ghafig2a, eval=F, fig.cap="Est. Proportions of Farm Holdings across Categories"}

par(mfrow=c(1,3), mar=c(3,3,0,.25))
plot(svytable(~croparea_4ha+cropsales_clas, gha.svy.shf), main=NA, las=1, col=9,
  ylab="Cultivated Area", xlab="Crop Commercialization 3-class")
plot(svytable(~croparea_4ha+noaggross_clas, gha.svy.shf), main=NA, las=1, col=36,
  ylab="Cultivated Area", xlab="Non-Farm Income 3-class")
plot(svytable(~croparea_4ha+class9, gha.svy.shf), main=NA, las=1, col=27,
  ylab="Cultivated Area", xlab="Typology 9-class")

```


```{r tab1, eval=F, results="asis"}

tmp <- svymean(~I(interaction(croparea_4ha, cropsales_clas, noaggross_clas)), gha.svy.farm, na.rm=T)
tmp.cv <- confint(tmp)
tmp <- cbind(as.data.table(tmp*100), as.data.table(tmp.cv*100))
tmp[`2.5 %`<0, `2.5 %` := 0]
tmp <- tmp[, lapply(.SD, function(x) format(x, digits=0, nsmall=1, scientific=F))]
tmp[, confint := paste(`2.5 %`, `97.5 %`, sep=" - ")]

tmp[, `:=`(
  croparea_4ha = factor(rep(levels(gha$croparea_4ha), 9)),
  cropsales_clas = factor(rep(levels(gha$cropsales_clas), each=2, 3), levels=c("LoC", "MeC", "HiC")),
  noaggross_clas = factor(rep(levels(gha$noaggross_clas), each=6, 1), levels=c("LoD", "MeD", "HiD"))
  )]

table_options(HTMLcaption="(#tab:tab1) Est. Proportions of Farm Holdings across Categories (percent)")
html(tabular(Heading()*noaggross_clas*(mean+confint)~Heading()*croparea_4ha*Heading()*cropsales_clas*Heading()*identity,
  data=tmp), rmarkdown=T, 
  caption="(#tab:tab1) Est. Proportions of Farm Holdings across Categories (percent)")

```


